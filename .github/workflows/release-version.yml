name: Repo version tagging from Gradle base

on:
  push:
    branches: [ '**' ]

jobs:
  ensure-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine next tag based on Gradle base and branch rules
        id: v
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${GITHUB_REF_NAME}"

          # Extract base version X.Y from Gradle file (line: version = "X.Y")
          if ! BASE=$(sed -n 's/^version = "\([0-9][0-9]*\.[0-9][0-9]*\)"/\1/p' build.gradle.kts | head -n1); then
            echo "Failed to parse base version from build.gradle.kts" >&2
            exit 1
          fi
          if [ -z "${BASE:-}" ]; then
            echo "Base version not found in build.gradle.kts (expected: version = \"X.Y\")" >&2
            exit 1
          fi

          SHORTSHA=$(git rev-parse --short=8 HEAD)

          # Get tags reachable from this branch (prefer ancestry correctness)
          MERGED_TAGS=$(git tag --merged HEAD || true)

          # Helper: find latest numeric tag for this base (X.Y.N) from a list
          find_latest_numeric() {
            echo "$1" | grep -E "^${BASE}\\.[0-9]+$" | sort -V | tail -n1 || true
          }

          # Determine latest numeric base tag
          LATEST_NUM=$(find_latest_numeric "$MERGED_TAGS")
          if [ -z "$LATEST_NUM" ]; then
            # Fallback: consider all tags in repo for this base
            ALL_TAGS=$(git tag --list "${BASE}.*" || true)
            LATEST_NUM=$(find_latest_numeric "$ALL_TAGS")
          fi

          if [ -z "$LATEST_NUM" ]; then
            # If none exists at all, start from patch 0 (will become .1 on master)
            LATEST_NUM="${BASE}.0"
          fi

          if [ "$BRANCH" = "master" ] || [ "$BRANCH" = "main" ]; then
            # Master/Main: bump numeric patch and tag X.Y.(N+1)
            PATCH=${LATEST_NUM##*.}
            NEXT_PATCH=$((10#$PATCH + 1))
            NEXT_TAG="${BASE}.${NEXT_PATCH}"
          else
            # Other branches: use latest numeric as base and add -<sha8>
            # If latest reachable tag already has -<sha>, ignore it and still use the numeric base
            NUMERIC_BASE="$LATEST_NUM"
            NEXT_TAG="${NUMERIC_BASE}-${SHORTSHA}"
          fi

          echo "next=${NEXT_TAG}" >> "$GITHUB_OUTPUT"
          echo "Computed next tag: ${NEXT_TAG}"

      - name: Create tag if this push is not a tag and tag doesn't already exist
        if: startsWith(github.ref, 'refs/heads/')
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          if git rev-parse -q --verify "refs/tags/${{ steps.v.outputs.next }}" >/dev/null; then
            echo "Tag ${{ steps.v.outputs.next }} already exists. Skipping."
          else
            git tag "${{ steps.v.outputs.next }}"
            git push origin "${{ steps.v.outputs.next }}"
          fi
