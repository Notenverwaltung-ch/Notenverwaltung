name: Build & Tag with Shared Version

on: [ push ]

jobs:
  compute-version:
    name: Compute Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      base: ${{ steps.version.outputs.base }}
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version from Gradle and compute patch
        id: version
        shell: bash
        run: |
          set -euo pipefail
          # Read major.minor from build.gradle.kts (version = "X.Y")
          BASE_VERSION=$(grep -E '^version\s*=\s*"[0-9]+\.[0-9]+"' build.gradle.kts | sed -E 's/.*"([0-9]+\.[0-9]+)"/\1/')
          if [ -z "$BASE_VERSION" ]; then
            echo "Could not determine base version from build.gradle.kts" >&2
            exit 1
          fi

          # If this workflow is triggered by pushing a tag, use that tag verbatim as VERSION
          if [ "${GITHUB_REF_TYPE:-}" = "tag" ]; then
            VERSION="${GITHUB_REF_NAME}"
            echo "version=$VERSION" >> "$GITHUB_OUTPUT"
            echo "base=$BASE_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BRANCH_NAME="${GITHUB_REF_NAME}"
          SHORT_SHA=$(git rev-parse --short HEAD)

          # Ensure we have all tags
          git fetch --tags --force

          # Find highest patch for tags like BASE_VERSION.Z without suffix
          HIGHEST_PATCH=$(git tag --list "${BASE_VERSION}.*" | grep -E "^${BASE_VERSION}\\.[0-9]+$" | sed -E "s/^${BASE_VERSION}\.([0-9]+)/\1/" | sort -n | tail -n1 || true)
          if [ -z "${HIGHEST_PATCH:-}" ]; then
            HIGHEST_PATCH=-1
          fi

          NEXT_PATCH=$((HIGHEST_PATCH + 1))

          if [ "$BRANCH_NAME" = "master" ] || [ "$BRANCH_NAME" = "main" ]; then
            VERSION="${BASE_VERSION}.${NEXT_PATCH}"
          else
            VERSION="${BASE_VERSION}.${NEXT_PATCH}-${SHORT_SHA}"
          fi

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "base=$BASE_VERSION" >> "$GITHUB_OUTPUT"

  build-and-tag:
    name: Tag, Build, Test, & Upload
    needs: compute-version
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Create and push tag
        env:
          VERSION: ${{ needs.compute-version.outputs.version }}
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          if git rev-parse -q --verify "refs/tags/${VERSION}" >/dev/null; then
            : # Tag already exists; no action needed
          else
            git tag -a "$VERSION" -m "Automated version tag $VERSION"
            git push origin "$VERSION"
          fi

      - name: Grant execute permission for Gradle
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Run tests
        run: ./gradlew test

      - name: Locate built jars and prepare artifact name
        id: jars
        env:
          VERSION: ${{ needs.compute-version.outputs.version }}
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p upload
          for f in build/libs/*.jar; do
            base="notenverwaltung-jars-${VERSION}"
            if [[ "$f" =~ (-plain|-sources|-javadoc)\.jar$ ]]; then
              classifier=$(echo "$f" | sed -E 's/.*(-plain|-sources|-javadoc)\.jar/\1/')
              cp "$f" "upload/${base}${classifier}.jar"
            else
              cp "$f" "upload/${base}.jar"
            fi
          done
          echo "dir=upload" >> "$GITHUB_OUTPUT"

      - name: Upload jars artifact
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-jars-${{ needs.compute-version.outputs.version }}
          path: ${{ steps.jars.outputs.dir }}

  latex:
    name: Build documentation PDF
    needs: compute-version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build PDF with latex-action
        uses: xu-cheng/latex-action@v3
        with:
          root_file: documentation.tex
          working_directory: documentation
          latexmk_use_lualatex: false
          latexmk_use_xelatex: false
          extra_system_packages: ghostscript
          args: -pdf -interaction=nonstopmode -halt-on-error -file-line-error
          pre_compile: |
            tlmgr update --self || true
            tlmgr install microtype ltablex ragged2e xurl listingsutf8 babel-german array pdflscape tikz || true
      - name: Prepare version-suffixed PDF
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          SRC="documentation/documentation.pdf"
          if [ ! -f "$SRC" ]; then
            echo "PDF not found: $SRC" >&2
            ls -al documentation || true
            exit 1
          fi
          cp "$SRC" "documentation/notenverwaltung-documentation-${{ needs.compute-version.outputs.version }}.pdf"

      - name: Upload PDF artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-documentation-${{ needs.compute-version.outputs.version }}
          path: documentation/notenverwaltung-documentation-${{ needs.compute-version.outputs.version }}.pdf

  docker:
    name: Build and push Docker image
    needs: [build-and-tag, compute-version]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}


      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download jar artifacts only
        uses: actions/download-artifact@v4
        with:
          pattern: notenverwaltung-jars*
          path: build/libs
          merge-multiple: true

      - name: Normalize JAR filename and verify presence
        run: |
          mkdir -p build/libs
          shopt -s nullglob
          JAR_CANDIDATES=(build/libs/*.jar build/libs/**/*.jar)
          COUNT=${#JAR_CANDIDATES[@]}
          if [ "$COUNT" -eq 0 ]; then
            find build -maxdepth 3 -type f -name "*.jar" -print || true
            exit 1
          fi
          SRC_JAR="${JAR_CANDIDATES[0]}"
          cp "$SRC_JAR" build/libs/app.jar
          cp build/libs/app.jar ./app.jar
        shell: bash


      - name: Set image tag (lowercase owner for GHCR)
        id: img
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "name=ghcr.io/${OWNER_LC}/notenverwaltung:${{ needs.compute-version.outputs.version }}" >> "$GITHUB_OUTPUT"

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ steps.img.outputs.name }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

  docker-frontend:
    name: Build and push Frontend Docker image
    needs: [compute-version]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Build Angular app (production)
        working-directory: frontend
        run: npx ng build --configuration=production

      - name: Upload frontend dist artifact
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-frontend-dist-${{ needs.compute-version.outputs.version }}
          path: frontend/dist/frontend-notenverwaltung

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute image tags
        id: imgfe
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "primary=ghcr.io/${OWNER_LC}/notenverwaltung-frontend:${{ needs.compute-version.outputs.version }}" >> "$GITHUB_OUTPUT"
          echo "latest=ghcr.io/${OWNER_LC}/notenverwaltung-frontend:latest" >> "$GITHUB_OUTPUT"

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: frontend
          file: frontend/Dockerfile
          push: true
          tags: |
            ${{ steps.imgfe.outputs.primary }}
            ${{ steps.imgfe.outputs.latest }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

  release:
    name: Create GitHub Release with artifacts
    needs: [build-and-tag, compute-version, latex, docker-frontend]
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Download release artifacts (PDFs and JARs)
        uses: actions/download-artifact@v4
        with:
          pattern: |
            notenverwaltung-*
          path: artifacts
          merge-multiple: true

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.compute-version.outputs.version }}
          name: ${{ needs.compute-version.outputs.version }}
          files: |
            artifacts/**
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}