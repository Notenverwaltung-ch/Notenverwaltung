name: Build & Tag with Shared Version

on: [ push ]

jobs:
  compute-version:
    name: Compute Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      base: ${{ steps.version.outputs.base }}
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version from Gradle and compute patch
        id: version
        shell: bash
        run: |
          set -euo pipefail
          # Read major.minor from build.gradle.kts (version = "X.Y")
          BASE_VERSION=$(grep -E '^version\s*=\s*"[0-9]+\.[0-9]+"' build.gradle.kts | sed -E 's/.*"([0-9]+\.[0-9]+)"/\1/')
          if [ -z "$BASE_VERSION" ]; then
            echo "Could not determine base version from build.gradle.kts" >&2
            exit 1
          fi

          # If this workflow is triggered by pushing a tag, use that tag verbatim as VERSION
          if [ "${GITHUB_REF_TYPE:-}" = "tag" ]; then
            VERSION="${GITHUB_REF_NAME}"
            echo "version=$VERSION" >> "$GITHUB_OUTPUT"
            echo "base=$BASE_VERSION" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          BRANCH_NAME="${GITHUB_REF_NAME}"
          SHORT_SHA=$(git rev-parse --short HEAD)

          # Ensure we have all tags
          git fetch --tags --force

          # Find highest patch for tags like BASE_VERSION.Z without suffix
          HIGHEST_PATCH=$(git tag --list "${BASE_VERSION}.*" | grep -E "^${BASE_VERSION}\\.[0-9]+$" | sed -E "s/^${BASE_VERSION}\.([0-9]+)/\1/" | sort -n | tail -n1 || true)
          if [ -z "${HIGHEST_PATCH:-}" ]; then
            HIGHEST_PATCH=-1
          fi

          NEXT_PATCH=$((HIGHEST_PATCH + 1))

          if [ "$BRANCH_NAME" = "master" ] || [ "$BRANCH_NAME" = "main" ]; then
            VERSION="${BASE_VERSION}.${NEXT_PATCH}"
          else
            VERSION="${BASE_VERSION}.${NEXT_PATCH}-${SHORT_SHA}"
          fi

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "base=$BASE_VERSION" >> "$GITHUB_OUTPUT"

  build-and-tag:
    name: Tag, Build, Test, & Upload
    needs: compute-version
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Create and push tag
        env:
          VERSION: ${{ needs.compute-version.outputs.version }}
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"
          if git rev-parse -q --verify "refs/tags/${VERSION}" >/dev/null; then
            : # Tag already exists; no action needed
          else
            git tag -a "$VERSION" -m "Automated version tag $VERSION"
            git push origin "$VERSION"
          fi

      - name: Grant execute permission for Gradle
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Run tests
        run: ./gradlew test

      - name: Collect app.jar artifact
        id: jars
        env:
          VERSION: ${{ needs.compute-version.outputs.version }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p upload
          if [ ! -f build/libs/app.jar ]; then
            echo "Expected build/libs/app.jar not found" >&2
            ls -al build/libs || true
            exit 1
          fi
          cp build/libs/app.jar "upload/notenverwaltung-app-${VERSION}.jar"
          echo "dir=upload" >> "$GITHUB_OUTPUT"

      - name: Upload jars artifact
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-jars-${{ needs.compute-version.outputs.version }}
          path: ${{ steps.jars.outputs.dir }}

  latex:
    name: Build documentation PDFs
    needs: compute-version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install TeX Live packages
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended texlive-pictures texlive-lang-german latexmk ghostscript

      - name: Build all .tex files
        id: buildtex
        shell: bash
        env:
          VERSION: ${{ needs.compute-version.outputs.version }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          outdir="documentation/build"
          mkdir -p "$outdir"
          built=()
          # Iterate .tex files that are standalone (contain \documentclass) and exclude asset directories
          while IFS= read -r -d '' file; do
            # Filter by content: only build if it contains \documentclass
            if ! grep -q '\\documentclass' "$file"; then
              echo "Skip (no \\documentclass): $file"
              continue
            fi
            rel="${file#documentation/}"               # e.g., documentation.tex or deployment/deployment.tex
            base="$(basename "$file" .tex)"           # e.g., documentation or deployment
            dir="$(dirname "$rel")"                   # e.g., . or deployment
            workdir="documentation/${dir}"
            echo "==> Building $rel in $workdir"
            (
              cd "$workdir"
              latexmk -pdf -interaction=nonstopmode -halt-on-error -file-line-error "$base.tex"
            )
            # Source PDF location after build
            srcpdf="documentation/${dir}/${base}.pdf"
            if [ ! -f "$srcpdf" ]; then
              echo "PDF not found after build: $srcpdf" >&2
              exit 1
            fi
            outpdf="$outdir/${base}-${VERSION}.pdf"
            cp "$srcpdf" "$outpdf"
            built+=("$outpdf")
          done < <(find documentation \( -path "*/images/*" -o -path "*/diagrams/*" -o -path "*/dump/*" -o -path "*/swagger/*" -o -path "*/testcases/*" \) -prune -o -type f -name "*.tex" -print0)

          if [ ${#built[@]} -eq 0 ]; then
            echo "No .tex files found to build under documentation/" >&2
            exit 1
          fi

          printf "Built PDFs:\n"
          printf ' - %s\n' "${built[@]}"
          echo "outdir=$outdir" >> "$GITHUB_OUTPUT"

      - name: Upload PDF artifacts
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-documentation-${{ needs.compute-version.outputs.version }}
          path: ${{ steps.buildtex.outputs.outdir }}

  docker:
    name: Build and push Docker image
    needs: [build-and-tag, compute-version]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}


      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download app jar artifact
        uses: actions/download-artifact@v4
        with:
          name: notenverwaltung-jars-${{ needs.compute-version.outputs.version }}
          path: build/libs

      - name: Normalize JAR filename and verify presence
        run: |
          mkdir -p build/libs
          shopt -s nullglob
          if [ ! -f build/libs/notenverwaltung-app-${{ needs.compute-version.outputs.version }}.jar ]; then
            echo "Downloaded app jar not found" >&2
            ls -al build/libs || true
            exit 1
          fi
          cp "build/libs/notenverwaltung-app-${{ needs.compute-version.outputs.version }}.jar" build/libs/app.jar
          cp build/libs/app.jar ./app.jar
        shell: bash


      - name: Compute image tags
        id: img
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "primary=ghcr.io/${OWNER_LC}/notenverwaltung:${{ needs.compute-version.outputs.version }}" >> "$GITHUB_OUTPUT"
          echo "latest=ghcr.io/${OWNER_LC}/notenverwaltung:latest" >> "$GITHUB_OUTPUT"

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: |
            ${{ steps.img.outputs.primary }}
            ${{ steps.img.outputs.latest }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

  docker-frontend:
    name: Build and push Frontend Docker image
    needs: [compute-version]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Build Angular app (production)
        working-directory: frontend
        run: npx ng build --configuration=production

      - name: Upload frontend dist artifact
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-frontend-dist-${{ needs.compute-version.outputs.version }}
          path: frontend/dist/frontend-notenverwaltung

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute image tags
        id: imgfe
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "primary=ghcr.io/${OWNER_LC}/notenverwaltung-frontend:${{ needs.compute-version.outputs.version }}" >> "$GITHUB_OUTPUT"
          echo "latest=ghcr.io/${OWNER_LC}/notenverwaltung-frontend:latest" >> "$GITHUB_OUTPUT"

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: frontend
          file: frontend/Dockerfile
          push: true
          tags: |
            ${{ steps.imgfe.outputs.primary }}
            ${{ steps.imgfe.outputs.latest }}
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}

  release:
    name: Create GitHub Release with artifacts
    needs: [build-and-tag, compute-version, latex, docker-frontend]
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Download release artifacts (PDFs and JARs)
        uses: actions/download-artifact@v4
        with:
          pattern: |
            notenverwaltung-*
          path: artifacts
          merge-multiple: true

      - name: Generate release body with Docker image links
        id: relbody
        shell: bash
        env:
          VERSION: ${{ needs.compute-version.outputs.version }}
          OWNER: ${{ github.repository_owner }}
        run: |
          set -euo pipefail
          OWNER_LC=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          {
            printf "%s\n" "# Docker Images"
            printf "%s\n" ""
            printf "%s\n" "The CI/CD pipeline built and published two Docker images to GitHub Container Registry for this release:"
            printf "%s\n" ""
            printf "%s\n" "- Backend API image:"
            printf "%s\n" "  - Pull/tag: ghcr.io/${OWNER_LC}/notenverwaltung:${VERSION}"
            printf "%s\n" "  - Package page: https://github.com/users/${OWNER}/packages/container/package/notenverwaltung"
            printf "%s\n" ""
            printf "%s\n" "- Frontend image:"
            printf "%s\n" "  - Pull/tag: ghcr.io/${OWNER_LC}/notenverwaltung-frontend:${VERSION} (also available as ghcr.io/${OWNER_LC}/notenverwaltung-frontend:latest)"
            printf "%s\n" "  - Package page: https://github.com/users/${OWNER}/packages/container/package/notenverwaltung-frontend"
            printf "%s\n" ""
            printf "%s\n" "Usage examples:"
            printf "%s\n" "- docker pull ghcr.io/${OWNER_LC}/notenverwaltung:${VERSION}"
            printf "%s\n" "- docker pull ghcr.io/${OWNER_LC}/notenverwaltung-frontend:${VERSION}"
          } > release_body.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.compute-version.outputs.version }}
          name: ${{ needs.compute-version.outputs.version }}
          files: |
            artifacts/**
          body_path: release_body.md
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}