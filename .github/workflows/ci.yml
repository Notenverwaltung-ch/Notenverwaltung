name: CI Build and Release

on:
  push:
    branches:
      - main
      - master
      - develop
      - feature/**
    tags: [ '*' ]
  pull_request:
    branches:
      - main
      - master
      - develop
      - feature/**

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: gradle

      - name: Grant execute permission for Gradle
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Run tests
        run: ./gradlew test

      - name: Compute pipeline artifact version
        id: pav
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
            VER="$GITHUB_REF_NAME"
          else
            # Read full semantic version from Gradle (e.g., 25.0.3)
            FULL=$(sed -n 's/^version = "\([0-9][0-9]*\.[0-9][0-9]*\(\.[0-9][0-9]*\)?\)"/\1/p' build.gradle.kts | head -n1)
            if [[ -z "$FULL" ]]; then
              FULL="0.0.0"
            fi
            SHORT_SHA=${GITHUB_SHA::7}
            if [[ "$GITHUB_REF_TYPE" == "branch" && ( "$GITHUB_REF_NAME" == "master" || "$GITHUB_REF_NAME" == "main" ) ]]; then
              VER="$FULL"
            else
              VER="${FULL}-${SHORT_SHA}"
            fi
          fi
          echo "version=$VER" >> "$GITHUB_OUTPUT"

      - name: Prepare version-suffixed JAR
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build/libs
          shopt -s nullglob
          CANDS=(build/libs/*.jar)
          # pick first non-plain
          PICK=""
          for j in "${CANDS[@]}"; do
            if [[ "$(basename "$j")" == *plain* ]]; then
              continue
            fi
            PICK="$j"; break
          done
          if [[ -z "$PICK" ]]; then
            echo "No non-plain jar found in build/libs" >&2
            ls -al build/libs || true
            exit 1
          fi
          install -d build/libs
          cp "$PICK" "build/libs/notenverwaltung-${{ steps.pav.outputs.version }}.jar"

      - name: Upload build artifact (version-suffixed non-plain JAR)
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-jar-${{ steps.pav.outputs.version }}
          path: build/libs/notenverwaltung-${{ steps.pav.outputs.version }}.jar

  docker:
    name: Build and push Docker image
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute docker tags
        id: dtags
        run: |
          REPO="ghcr.io/${GITHUB_REPOSITORY,,}"
          SHORT_SHA=${GITHUB_SHA::7}
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          TAGS=""
          PUSH=false
          if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
            # Use the tag name as docker tag (no leading 'v' assumed)
            TAGS+="$REPO:${GITHUB_REF_NAME}"
            PUSH=true
          elif [[ "$GITHUB_REF_TYPE" == "branch" && "$GITHUB_REF_NAME" == feature/* ]]; then
            SAFE_BRANCH=${GITHUB_REF_NAME//\//-}
            TAGS+="$REPO:${SAFE_BRANCH}-${SHORT_SHA}"
          else
            SAFE_REF=${GITHUB_REF_NAME//\//-}
            TAGS+="$REPO:${SAFE_REF}-${SHORT_SHA}"
          fi
          # docker/build-push-action accepts newline or comma separated list
          # Use newline to be safe. Use proper heredoc to avoid echo -e pitfalls.
          {
            echo "tags<<EOF"
            echo "$TAGS"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          echo "push=$PUSH" >> $GITHUB_OUTPUT
          if [[ "$PUSH" == "true" && -z "$TAGS" ]]; then
            echo "[ERROR] Push requested but no docker tags were computed" >&2
            exit 1
          fi
        shell: bash

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download artifacts (all)
        uses: actions/download-artifact@v4
        with:
          path: build/libs
          merge-multiple: true

      - name: Normalize JAR filename and verify presence
        run: |
          mkdir -p build/libs
          shopt -s nullglob
          JAR_CANDIDATES=(build/libs/*.jar build/libs/**/*.jar)
          COUNT=${#JAR_CANDIDATES[@]}
          if [ "$COUNT" -eq 0 ]; then
            find build -maxdepth 3 -type f -name "*.jar" -print || true
            exit 1
          fi
          SRC_JAR="${JAR_CANDIDATES[0]}"
          cp "$SRC_JAR" build/libs/app.jar
          cp build/libs/app.jar ./app.jar
        shell: bash

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: ${{ steps.dtags.outputs.push == 'true' }}
          tags: ${{ steps.dtags.outputs.tags }}

      - name: How to pull and run the image
        if: ${{ steps.dtags.outputs.push == 'true' }}
        run: |
          echo "Docker image pushed to GHCR."
          echo ""
          echo "Repository: ghcr.io/${GITHUB_REPOSITORY,,}"
          echo ""
          echo "Pull and run commands for all tags:"
          while IFS= read -r tag; do
            [ -n "$tag" ] || continue
            echo "  docker pull $tag"
            echo "  docker run --rm -p 8080:8080 $tag"
          done <<< "${{ steps.dtags.outputs.tags }}"
          echo ""
          echo "If needed, authenticate with GHCR first:"
          echo "  echo \"${{ secrets.GITHUB_TOKEN }}\" | docker login ghcr.io -u ${{ github.actor }} --password-stdin"
        shell: bash


  latex:
    name: Build documentation PDF
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build PDF with latex-action
        uses: xu-cheng/latex-action@v3
        with:
          root_file: documentation.tex
          working_directory: documentation
          latexmk_use_lualatex: false
          latexmk_use_xelatex: false
          extra_system_packages: ghostscript
          args: -pdf -interaction=nonstopmode -halt-on-error -file-line-error
          pre_compile: |
            tlmgr update --self || true
            tlmgr install microtype ltablex ragged2e xurl listingsutf8 babel-german array || true

      - name: Compute pipeline artifact version
        id: pav
        shell: bash
        run: |
          set -euo pipefail
          if [[ "$GITHUB_REF_TYPE" == "tag" ]]; then
            VER="$GITHUB_REF_NAME"
          else
            # Read full semantic version from Gradle (e.g., 25.0.3)
            FULL=$(sed -n 's/^version = "\([0-9][0-9]*\.[0-9][0-9]*\(\.[0-9][0-9]*\)?\)"/\1/p' build.gradle.kts | head -n1)
            if [[ -z "$FULL" ]]; then
              FULL="0.0.0"
            fi
            SHORT_SHA=${GITHUB_SHA::7}
            if [[ "$GITHUB_REF_TYPE" == "branch" && ( "$GITHUB_REF_NAME" == "master" || "$GITHUB_REF_NAME" == "main" ) ]]; then
              VER="$FULL"
            else
              VER="${FULL}-${SHORT_SHA}"
            fi
          fi
          echo "version=$VER" >> "$GITHUB_OUTPUT"

      - name: Prepare version-suffixed PDF
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          SRC="documentation/documentation.pdf"
          if [ ! -f "$SRC" ]; then
            echo "PDF not found: $SRC" >&2
            ls -al documentation || true
            exit 1
          fi
          cp "$SRC" "documentation/notenverwaltung-documentation-${{ steps.pav.outputs.version }}.pdf"

      - name: Upload PDF artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: notenverwaltung-documentation-${{ steps.pav.outputs.version }}
          path: documentation/notenverwaltung-documentation-${{ steps.pav.outputs.version }}.pdf

  release:
    name: Create GitHub Release with artifacts
    needs: [build, latex]
    # Only run on tag refs to ensure clean numeric version tags (e.g., 25.0.1) and avoid SHA-suffixed tags on master
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version from tag
        id: ver
        shell: bash
        run: |
          # Release job only runs on tags; use the tag name as version
          echo "version=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: notenverwaltung-jar-${{ steps.ver.outputs.version }}
          path: artifacts
          merge-multiple: true

      - name: Download documentation PDF artifact
        uses: actions/download-artifact@v4
        with:
          name: notenverwaltung-documentation-${{ steps.ver.outputs.version }}
          path: artifacts
          merge-multiple: true


      - name: Collect and rename release files
        run: |
          set -euo pipefail
          VERSION="${{ steps.ver.outputs.version }}"
          mkdir -p release
          # Find JAR built by Gradle
          shopt -s nullglob
          JARS=(artifacts/*.jar artifacts/build/libs/*.jar artifacts/**/*.jar)
          # Filter out any jar that contains 'plain' in its name
          FILTERED_JARS=()
          for j in "${JARS[@]}"; do
            [[ "$(basename "$j")" == *plain* ]] && continue
            FILTERED_JARS+=("$j")
          done
          if [ ${#FILTERED_JARS[@]} -eq 0 ]; then
            echo "No non-plain JAR found in artifacts" >&2
            find artifacts -type f -name "*.jar" -print || true
            exit 1
          fi
          cp "${FILTERED_JARS[0]}" "release/notenverwaltung-${VERSION}.jar"
          # Find PDF (accept any pdf)
          PDFS=(artifacts/*.pdf artifacts/**/*.pdf)
          if [ ${#PDFS[@]} -eq 0 ]; then
            echo "No PDF found in artifacts" >&2
            find artifacts -type f -name "*.pdf" -print || true
            exit 1
          fi
          PDF_CANDIDATE="${PDFS[0]}"
          cp "$PDF_CANDIDATE" "release/Dokumentation-${VERSION}.pdf"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.ver.outputs.version }}
          name: ${{ steps.ver.outputs.version }}
          files: |
            release/notenverwaltung-${{ steps.ver.outputs.version }}.jar
            release/Dokumentation-${{ steps.ver.outputs.version }}.pdf
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
